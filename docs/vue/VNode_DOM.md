# ä»VNodeåˆ°DOM

å¯¼è¯»ï¼š å¼€å‘è€…åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå®é™…ä¸Šå¹¶æ²¡æœ‰æ“ä½œDOMï¼Œè€Œæ˜¯ä½¿ç”¨æ¨¡ç‰ˆè¯­æ³•æ„é€ äº†renderå‡½æ•°ã€‚æ•´ä¸ªä»VNodeåˆ°DOMçš„è¿‡ç¨‹éå¸¸å€¼å¾—ä»”ç»†æ¨æ•²ã€‚

### renderå‡½æ•°

å…ˆå¼•å…¥ä¸¤ä¸ªæ—¶æœºç‚¹ï¼š
1. åœ¨å¼•å…¥Vueæ—¶ï¼Œè°ƒç”¨äº†`renderMixin`æ–¹æ³•ã€‚å®ƒåœ¨Vueæ„é€ å‡½æ•°çš„åŸå‹é“¾ä¸Šï¼Œæ··å…¥äº†ä¸€äº›æ–¹æ³•ï¼Œæœ€ä¸»è¦çš„ä¸¤ä¸ªæ˜¯`$nextTick`å‡½æ•°å’Œä¸‹æ–¹çš„`_render`å‡½æ•°ã€‚

```js
  Vue.prototype._render = function () {

    const { render, _parentVnode } = vm.$options

    vnode = render.call(vm._renderProxy, vm.$createElement)
  }
```

2. åœ¨newä¸€ä¸ªVueå®ä¾‹è¿‡ç¨‹ä¸­ï¼Œè¿˜è°ƒç”¨äº†`initRender`æ–¹æ³•ã€‚è¿™ä¸ªå‡½æ•°ï¼Œå¾€å½“å‰çš„vueå®ä¾‹é‡ŒåŠ äº†ä¸€äº›å˜é‡ã€‚
```js
  // å†…éƒ¨è°ƒç”¨
  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  // å¼€å‘è€…è°ƒç”¨
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
```
ä¸¤è€…çš„åŒºåˆ«å°±æ˜¯æœ€åçš„å‚æ•°ï¼Œè¿™ä¸ªå½±å“åˆ°äº†`normalizationType`å˜é‡ã€‚

å¦‚æœå¼€å‘è€…è‡ªå·±å†™å‡ºä¸€äº›renderå‡½æ•°ï¼Œä¾‹å¦‚ï¼š
```js
{
  render (h) {
    return h('div', {
      attrs: {
        id: 'title'
      }
    }, ['textNode'])
  }
}
```

::: tip
åœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥å…ˆä¸‹ä¸ªç»“è®ºï¼Œ`h`å®é™…ä¸Šå°±æ˜¯`vm.$createElement`ï¼Œå› ä¸ºåœ¨æ‰§è¡Œ`_render`å‡½æ•°æ—¶ï¼Œç»™`render`å‡½æ•°æ³¨å…¥çš„ç¬¬ä¸€ä¸ªå…¥å‚å°±æ˜¯`vm.$createElement`ã€‚
:::

### $createElement å’Œ VNode

$createElementå‡½æ•°æœ€ç»ˆä¼šè¿”å›ä¸€ä¸ªVNodeå¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡æ˜¯DOMçš„ä¸€ä¸ªç®€ç‰ˆï¼Œå…ˆä¸è¡¨ã€‚

åœ¨ç”Ÿæˆæ•´ä¸ªvnodeçš„è¿‡ç¨‹ä¸­ï¼Œ`$createElement`ã€`createElement`ã€`_createElement`è¿™å‡ ä¸ªå‡½æ•°å…ˆåè°ƒç”¨ã€‚ PS: ç¯‡å¹…å…³ç³»ï¼Œåœ¨_createElementå‡½æ•°ä¸­é—´åˆ é™¤äº†å¾ˆå¤šæºç ã€‚`_createElementçš„æºç å¯ä»¥åœ¨/src/core/vdom/create-element.jsæ–‡ä»¶ä¸­çœ‹åˆ°ã€‚`

```js

vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)

export function createElement (
  context: Component,
  tag: any,
  data: any,
  children: any,
  normalizationType: any,
  alwaysNormalize: boolean
): VNode | Array<VNode> {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE
  }
  return _createElement(context, tag, data, children, normalizationType)
}

export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
  if (isDef(data) && isDef((data: any).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` +
      'Always create fresh vnode data objects in each render!',
      context
    )
    return createEmptyVNode()
  }

  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
```

1. $createElementå‡½æ•°çš„å°è£…æ˜¯ä¸ºäº†åŠ¨æ€çš„è·å–vmã€‚
2. createElementå‡½æ•°æ˜¯ä¸ºäº†è®©å‚æ•°æ›´çµæ´»ã€‚å¼€å‘è€…å¯ä»¥åœ¨ç¬¬äºŒä¸ªå‚æ•°å†™å­èŠ‚ç‚¹æ•°ç»„ã€‚
3. _createElementå‡½æ•°çœŸæ­£æ„ä¹‰ä¸Šçš„åˆ›å»ºäº†vNodeã€‚

### childrenè§„èŒƒåŒ–

æˆ‘ä»¬çŸ¥é“åœ¨ä¸€ä¸ªç»„ä»¶ä¸­å¿…ä¸å¯å°‘çš„å°±æ˜¯å­èŠ‚ç‚¹ã€‚é¦–å…ˆæ ¹æ®`normalizationType`çš„ä¸åŒï¼Œè°ƒç”¨äº†ä¸åŒæ–¹æ³•ï¼Œ**è§„èŒƒåŒ–children**ã€‚

```js
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
  }
```

`normalizeChildren`è¢«è°ƒç”¨æœ‰ä¸¤ç§åœºæ™¯ï¼š
1. å½“å¼€å‘è€…ä½¿ç”¨äº†æ‰‹å†™å½“renderå‡½æ•°ã€‚
2. ç¼–è¯‘slotã€v-forçš„æ—¶å€™ä¼šäº§ç”ŸåµŒå¥—æ•°ç»„çš„æƒ…å†µã€‚

è¯¥å‡½æ•°é€šè¿‡forå¾ªç¯ï¼Œè·å¾—å•ä¸ªèŠ‚ç‚¹`c`å˜é‡ï¼Œç„¶åæŒ‰ç…§èŠ‚ç‚¹`c`çš„ç±»å‹å»å¤„ç†ã€‚
1. æ•°ç»„ç±»å‹,é€’å½’è°ƒç”¨normalizeArrayChildrenå‡½æ•°
2. åŸºç¡€ç±»å‹ï¼Œé€šè¿‡`createTextVNode`æ–¹æ³•è½¬æ¢æˆVNodeç±»å‹ã€‚
3. å¦å¤–éƒ½æ˜¯vnodeçš„æƒ…å†µï¼Œç„¶åv-forç”Ÿæˆçš„vnodeä¼šåœ¨å¢åŠ ä¸ªkeyçš„å±æ€§
æœ€åè¿”å›vnodeæ•°ç»„ã€‚ä¸‹é¢æ˜¯ä¼ªä»£ç ï¼Œäº‹å®ä¸Šï¼Œvueè¿˜è€ƒè™‘åˆ°åˆå¹¶textNodeè¿™ç±»çš„æƒ…å†µã€‚

```js
      if (Array.isArray(c)) {
        // 
      } else if (isPrimitive(c)) {
        // 
      } else {
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) &&
            isDef(c.tag) &&
            isUndef(c.key) &&
            isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
```

### æ„å»ºvnode

```js
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (isDef(data) && isDef(data.nativeOn)) {
        warn(
          ("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">."),
          context
        );
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
```

1. tagå˜é‡æ˜¯stringã€‚
  * å†…ç½®çš„èŠ‚ç‚¹ï¼Œåˆ›å»ºæ™®é€šVNode
  * æˆ–æ˜¯å·²ç»æ³¨å†Œçš„componentNameï¼Œåˆ™é€šè¿‡`createComponent`åˆ›å»ºä¸€ä¸ªcomponent Vnode
  * å…¶ä»–åˆ™æ˜¯åˆ›å»ºä¸€ä¸ªæœªçŸ¥æ ‡ç­¾çš„VNode
2. å…¶ä»–æƒ…å†µä¸‹ï¼Œå°±é€šè¿‡`createComponent`åˆ›å»ºä¸€ä¸ªcomponent Vnodeï¼ˆé‚£å½“tagç±»å‹æ˜¯ä¸€äº›nullï¼Œæˆ–undefinedå€¼ï¼Œæ˜¯å¦ä¼šæœ‰åšå¤„ç†å‘¢ï¼Ÿ ç­”ï¼šè¿™ä¸ªåœ¨å¤„ç†å­èŠ‚ç‚¹å‰ï¼Œå°±å·²ç»è¿”å›empty VNodeäº†ã€‚ï¼‰

### æ¸²æŸ“åˆ°DOM(_update)

å†æ¬¡å›åˆ°å…ˆå‰çš„`Vue.prototype._render`å‡½æ•°ã€‚æ‰§è¡Œå®Œrenderå‡½æ•°åè·å–åˆ°äº†vnodeï¼Œåœ¨éšåå¾—æ ¡éªŒvnodeçš„æ ¼å¼ã€‚ä¾‹å¦‚ä¸èƒ½æ˜¯æ•°ç»„ç­‰ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ï¼Œæœ€å_renderå‡½æ•°å°±è¿”å›äº†vnodeã€‚

æ­¤æ—¶ä¸‹ä¸€æ­¥å°±æ‰§è¡Œvm._update(vm._render(), hydrating);åé¢é‚£ä¸ªå‚æ•°ä¸ç”¨ç®¡ï¼Œå®ƒæ˜¯SSRæ—¶æ‰ç”¨åˆ°çš„ï¼Œæ­¤æ—¶å°±æ˜¯`undefined`ã€‚è¯¥å‡½æ•°çš„å®šä¹‰åœ¨`src/core/instance/lifecycle.js`ä¸­ã€‚

```js
  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  }
```

_updateå‡½æ•°ä»…æœ‰30è¡Œä»£ç ï¼Œæ ¸å¿ƒå°±æ˜¯æ‰§è¡Œ__patch__å‡½æ•°ã€‚**è§¦å‘__patch__å‡½æ•°æœ‰ä¸¤ä¸ªæ—¶æœºï¼Œä¸€æ˜¯åˆæ¬¡æ¸²æŸ“çš„æ—¶å€™ï¼ŒäºŒæ˜¯å½“æ•°æ®æ›´æ–°é€šçŸ¥`renderWatcheræ›´æ–°æ—¶`ã€‚**è¿™ä¸¤è€…çš„ä¸åŒç‚¹å°±æ˜¯æ˜¯å¦å­˜åœ¨`preVnode`ã€‚å€¼å¾—ä¸€æçš„æ˜¯`__patch__`å‡½æ•°åœ¨ä¸åŒçš„è¿è¡Œç¯å¢ƒï¼Œä¹Ÿæ˜¯ä¸åŒçš„ã€‚

* webç«¯ ï¼ˆå®šä¹‰åœ¨src/platforms/web/runtime/index.jsï¼‰
* weexç«¯ ï¼ˆå®šä¹‰åœ¨src/platforms/weex/runtime/index.jsï¼‰

`patch`å‡½æ•°æ˜¯é€šè¿‡`createPatchFunction`å‡½æ•°è¿”å›çš„ï¼Œ`createPatchFunction`å‡½æ•°æ€»å…±æœ‰700å¤šè¡Œä»£ç ï¼Œæ˜¯æˆ‘ç›®å‰ä¸ºæ­¢çœ‹åˆ°è¿‡çš„æœ€é•¿çš„å‡½æ•°äº†ğŸ¶ã€‚

```js
// src/platforms/web/runtime/patch.js

export const patch: Function = createPatchFunction({ nodeOps, modules })
```

nodeOpså‚æ•°æ˜¯ä¸€äº›å‡½æ•°ï¼Œå…³äºæ“ä½œdomçš„ã€‚è€Œmodulesåˆ™æ˜¯ä¸€äº›æ¨¡å—çš„é’©å­å‡½æ•°çš„å®ç°ã€‚
`createPatchFunction`å‡½æ•°å®šä¹‰åœ¨`src/core/vdom/patch.js`ï¼Œå‡½æ•°å†…éƒ¨å£°æ˜äº†äº†å¾ˆå¤šæ–¹æ³•ï¼Œè€Œè¿™äº›å‡½æ•°çš„å®ç°åˆ™æ˜¯æ¥è‡ªå‡½æ•°çš„å‚æ•°ä¸­çš„ä¸€äº›DOMæ“ä½œæ–¹æ³•ã€‚è¿™æ ·åŒºåˆ«åŒ–æ˜¯å› ä¸ºåœ¨ä¸åŒå¹³å°patchçš„æ€æƒ³æ˜¯é«˜åº¦ç›¸ä¼¼çš„ï¼Œä½†æ˜¯å¹³å°é—´çš„æ“ä½œæ–¹æ³•åˆ™ä¸åŒã€‚

åœ¨å›åˆ°patchå‡½æ•°æœ¬èº«ï¼Œå®ƒæœ‰å››ä¸ªå…¥å‚åˆ†åˆ«æ˜¯ï¼š
1. oldVnode, å…ˆå‰çš„vnodeæˆ–æ˜¯çœŸå®çš„DOMèŠ‚ç‚¹ï¼ˆç¬¬ä¸€æ¬¡æ¸²æŸ“æ—¶ï¼‰
2. vnode, renderå‡½æ•°ç”Ÿæˆçš„vnode
2. hydrating, SSRç›¸å…³çš„å‚æ•°
3. removeOnly, æä¾›ç»™`transition-group`ç»„ä»¶

```js
// patchå‡½æ•°ç‰‡æ®µ
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            } else if (process.env.NODE_ENV !== 'production') {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              )
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode)
        }

        // replacing existing element
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )
```

åœ¨åˆæ¬¡æ¸²æŸ“æ—¶ï¼Œä¼šèµ°å…¥åˆ°è¿™ä¸ªåˆ†æ”¯ã€‚åœ¨åˆ¤æ–­ä¸æ˜¯æœåŠ¡å™¨æ¸²æŸ“åï¼Œå°±å°†åŸå…ˆçš„çœŸå®DOMï¼ˆå‚æ•°åå«vnodeï¼‰æ›¿æ¢æˆä¸€ä¸ªç©ºvnodeã€‚
ç„¶åç¥å¥‡çš„äº‹æ¥äº†ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“ç»‘å®šçš„æŸä¸ªå…ƒç´ ä¾‹å¦‚`<div id="#app"></div>`æœ€åä¼šè¢«æ•´ä¸ªç»„ä»¶å…ƒç´ æ‰€å–ä»£ã€‚åœ¨è¿™é‡Œå°±èƒ½è¯´æ˜äº†ï¼Œè·å–äº†æ—§å…ƒç´ å’Œå…¶ç¥–å…ˆå…ƒç´ åï¼Œä¸‹ä¸€æ­¥å°±æ˜¯å°†æ—§å…ƒç´ ç§»é™¤ï¼ŒæŠŠæ–°å…ƒç´ åŠ å…¥åˆ°çˆ¶å…ƒç´ ä¸­ã€‚

æ¥ä¸‹æ¥çš„createElm()å°±å°¤å…¶é‡è¦äº†ã€‚åœ¨æ­¤æ¬¡è°ƒç”¨ä¸­ï¼Œä¼ å…¥äº†4ä¸ªå‚æ•°ã€‚

* vnode
* insertedVnodeQueue: ç©ºæ•°ç»„
* ç¥–å…ˆå…ƒç´ 
* é‚»å±…èŠ‚ç‚¹

```js
    function createElm (
      vnode,
      insertedVnodeQueue,
      parentElm,
      refElm,
      nested,
      ownerArray,
      index
    ) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // This vnode was used in a previous render!
        // now it's used as a new node, overwriting its elm would cause
        // potential patch errors down the road when it's used as an insertion
        // reference node. Instead, we clone the node on-demand before creating
        // associated DOM element for it.
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      vnode.isRootInsert = !nested; // for transition enter check
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {
        {
          if (data && data.pre) {
            creatingElmInVPre++;
          }
          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
            warn(
              'Unknown custom element: <' + tag + '> - did you ' +
              'register the component correctly? For recursive components, ' +
              'make sure to provide the "name" option.',
              vnode.context
            );
          }
        }

        vnode.elm = vnode.ns
          ? nodeOps.createElementNS(vnode.ns, tag)
          : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }

        if (data && data.pre) {
          creatingElmInVPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }
```
åœ¨è¿™é‡Œæˆ‘ä»¬å…ˆå¿½ç•¥createComponentè¿™ä¸ªæ–¹æ³•ã€‚

1. é¦–å…ˆåˆ›å»ºäº†è¯¥èŠ‚ç‚¹çš„å…ƒç´ ï¼Œå¹¶é™„åŠ åˆ°vnodeä¸Šã€‚
  é€šè¿‡`createElement`æˆ–`createElementNS`è¿™ä¸¤ä¸ªæ–¹æ³•ã€‚
2. `createChildren()`
  æ•´ä¸ªVNodeæ¨¡å‹å°±æ˜¯å¤šå‰æ ‘ï¼Œæ‰€ä»¥å‡½æ•°å†…éƒ¨å°±æ˜¯æ·±åº¦éå†åˆ›å»ºå­æ ‘ã€‚ä¸­é—´å†æ¬¡è°ƒç”¨äº†createElemè¿™ä¸ªå‡½æ•°ã€‚
  ç„¶åcommentèŠ‚ç‚¹å’ŒtextNodeèŠ‚ç‚¹æ¯”è¾ƒç‰¹æ®Šï¼Œæ˜¯åœ¨ä¸¤ä¸ªelseè¯­å¥ä¸­ã€‚
3. `insert(parentElm, vnode.elm, refElm)`
  è¿™ä¸‰ä¸ªå‚æ•°åˆ†åˆ«æ˜¯çˆ¶èŠ‚ç‚¹ï¼Œvnodeåˆ›å»ºçš„çœŸå®domï¼Œä»¥åŠé‚»å±…èŠ‚ç‚¹ã€‚è¿™ä¸€æ­¥å°†çœŸå®çš„domèŠ‚ç‚¹æ¸²æŸ“åˆ°domä¸Šäº†ã€‚

è¿”å›åˆ°`__patch`å‡½æ•°ä¸­, åˆ›å»ºå®Œå…³äºvnodeç›¸å…³çš„èŠ‚ç‚¹å¹¶æ’å…¥åˆ°å¯¹åº”çš„ä½ç½®åï¼Œå°±å¾—å°†åŸå…ˆçš„èŠ‚ç‚¹ç§»é™¤ã€‚
```js
  // patchå‡½æ•°ç‰‡æ®µ
    // destroy old node
    if (isDef(parentElm)) {
      removeVnodes([oldVnode], 0, 0);
    } else if (isDef(oldVnode.tag)) {
      invokeDestroyHook(oldVnode);
    }

  function removeVnodes (vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      const ch = vnodes[startIdx]
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch)
          invokeDestroyHook(ch)
        } else { // Text node
          removeNode(ch.elm)
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      let i
      const listeners = cbs.remove.length + 1
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners)
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm)
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm)
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm)
      } else {
        rm()
      }
    } else {
      removeNode(vnode.elm)
    }
  }
```
åœ¨æœ¬æ¬¡è¿™ä¸ªæ¡ˆä¾‹ä¸­ï¼Œrmå‚æ•°ä¸å­˜åœ¨ï¼Œæ‰€ä»¥ç›´æ¥èµ°åˆ°äº†elseåˆ†æ”¯ä¸­ï¼Œç§»é™¤äº†oldVNodeå¯¹åº”çš„DOMå…ƒç´ ã€‚æœ€ååœ¨æ‰§è¡Œæ¯ä¸ªå…ƒç´ çš„destroyçš„hookæ•°ç»„ï¼Œå¦‚æœvnodeå­˜åœ¨å­èŠ‚ç‚¹åˆ™é€’å½’å¤„ç†ã€‚
æœ€åè¿”å›vnodeå¯¹åº”çš„DOMèŠ‚ç‚¹ï¼Œpatchå‡½æ•°å°±åŸºæœ¬æ‰§è¡Œå®Œæ¯•äº†ã€‚